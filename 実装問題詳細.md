# 実装問題詳細（MSAL/認証・フロント）

ステップ運用の注意:
- 本ドキュメントでは各項目に、該当するステップ番号（【Step 1】〜【Step 4】）を併記します。
- ステップ3・4の項目については状況把握のためチェックを行いますが、のちの集計には含めません（ステップ1・2のみ集計対象）。

本ドキュメントは「進捗確認チェックリスト」の MSAL/認可/バックエンド検証/リダイレクト などの「[!] 実装に問題あり」の根拠と修正方針を、実コード抜粋付きで整理したものです。

## 統合版（重複解消・簡潔）

### 【Step 1】認証・認可（MSAL/Access Token/JWT/roles）
- 要修正（MSAL設定/redirect/knownAuthorities）:
  - `authority`/`knownAuthorities`/`redirectUri` を実運用（CIAM/B2C 等）に整合。
  - 参考: `src/azure-config.ts` の `auth.authority` が `login.microsoftonline.com` 固定、`knownAuthorities` 未設定。
- 要修正（Access Token 付与/401再試行）:
  - API 呼出時は必ず Access Token（`Authorization: Bearer`）を付与。401 は silent→再試行→失敗時ログアウト誘導。
  - 参考: `src/lib/azureApi.ts` の `request()` に Bearer 未注入。
- 要修正（ロール判定の統一）:
  - `roles`（appRoles）か `groups` のいずれかへ統一（Admin 名称固定）。
  - 参考: `useMsalAuth.ts` は `groups`、`useAuthInit-azure.ts` は `roles` を参照。
- 要修正（バックエンドのJWT検証/認可）:
  - すべての HTTP 関数で issuer/aud/scp/exp 検証、エンドポイント認可（Admin/所有者/組織）を実装。

### 【Step 2】ストレージ（コンテナ分離/階層/CORS/非公開、SASアップロード/ダウンロード/削除）
- 要修正（コンテナ分離/命名・階層/CORS/非公開）:
  - 入力= `transcripts`、出力= `outputs` に統一。階層は `private/{oid}/{sessionId}/…`。
  - CORS は AllowedOrigins/Methods/Headers/ExposeHeaders/MaxAge を最小化。Public access は無効。
  - 参考: `src/azure-config.ts`（`transcripts`/`outputs`）と `api/GetUploadSasUrl/index.ts`（`uploads`）。
- 要修正（アップロードSAS）:
  - JWT 必須、権限は `add/create/write` のみ、期限≦10分、`startsOn` 付与。`blobName` はサーバで決定し返却。
  - 参考: `GetUploadSasUrl` が `authLevel: "anonymous"`、`permissions.read=true`、期限1時間、`uuid-ファイル名`。
- 要修正（ダウンロード/削除）:
  - ダウンロードSAS API/削除API を実装。JWT 検証＋所有者/組織検証、SAS は `read` のみ/短期、削除は関数経由、監査/相関IDを記録。
  - 参考: `src/lib/azureApi.ts` にエンドポイント参照はあるが実装が未整備。

注: 以降は詳細（アーカイブ）です。上記「統合版」を最新の基準として参照してください。

---

## 【Step 1】1. API呼び出しに Authorization ヘッダ未付与（Access Token 不使用）

現状、Functions 呼び出しの共通クライアントで Bearer トークンを付与していません。

```tsx
// src/lib/azureApi.ts（抜粋）
async function request<T = any>(path: string, init?: RequestInit): Promise<T> {
  // NO token logic here for Milestone 1
  const headers: Record<string, string> = {
    "Content-Type": "application/json",
  };
  const res = await fetch(buildUrl(path), {
    method: "POST",
    headers,
    ...init,
  });
  // ...
}
```

- 影響: APIが保護されず、Access Token 検証ができない（認可・監査の破綻）。
- 修正方針: `acquireTokenSilent` で `api://.../access_as_user` の Access Token を取得し、`Authorization: Bearer <token>` を必ず付与。401 なら再取得→再試行（限度回数）→ログアウト誘導。

---

## 【Step 1】2. スコープ不統一／APIスコープ未設定

`msal.ts` に独自 `loginRequest` が定義され、APIスコープが含まれていません。一方 `azure-config.ts` には API スコープを含む `tokenRequest` が定義されています。

```ts
// src/lib/msal.ts（抜粋）
export const loginRequest = {
  scopes: ["openid", "offline_access"],
};
```

```ts
// src/azure-config.ts（抜粋）
export const loginRequest = {
  scopes: ["openid", "profile", "email", "offline_access"],
  prompt: "select_account",
};
export const tokenRequest = {
  scopes: [
    "openid",
    "profile",
    "email",
    "offline_access",
    `api://${process.env.NEXT_PUBLIC_API_CLIENT_ID}/access_as_user`,
  ],
  forceRefresh: false,
};
```

- 影響: Access Token に API スコープが含まれない／誤った要求によりトークン取得失敗。
- 修正方針: `loginRequest`/`tokenRequest` を一本化（API スコープを含める）。呼び出し側は `tokenRequest` を使用して Access Token を取得。

---

## 【Step 1】3. 権限判定の不一致（roles vs groups）

`useMsalAuth` は `groups` を使用、`useAuthInit-azure` は `roles` を使用しています。

```ts
// src/hooks/useMsalAuth.ts（抜粋）
const convertMsalAccountToUser = (msalAccount: any) => ({
  userId: msalAccount.localAccountId || msalAccount.homeAccountId,
  username: msalAccount.username || msalAccount.name || "Unknown User",
  email: msalAccount.username,
  groups: msalAccount.idTokenClaims?.groups || [],
});
```

```ts
// src/hooks/useAuthInit-azure.ts（抜粋）
const idTokenClaims = account.idTokenClaims as any;
const roles = idTokenClaims?.roles || [];
const isAdmin = roles.includes('Admin') || roles.includes('admin');
```

- 影響: Admin 判定が環境により揺らぎ、UI/アクセス制御が不安定に。
- 修正方針: テナント方針に合わせてどちらかに統一（推奨: appRoles=`roles`）。もう一方を利用しない。判定ロジックは共通ヘルパー化。

---

## 【Step 1】4. 設定整合性（authority / knownAuthorities / redirectUri）

`authority` が `login.microsoftonline.com` 固定で、External ID/B2C 構成時に整合しない可能性。`knownAuthorities` も未設定です。

```ts
// src/azure-config.ts（抜粋）
auth: {
  clientId: process.env.NEXT_PUBLIC_FRONTEND_CLIENT_ID || "",
  authority: `https://login.microsoftonline.com/${process.env.NEXT_PUBLIC_TENANT}`,
  redirectUri: process.env.NEXT_PUBLIC_REDIRECT_URI || "http://localhost:3000",
  postLogoutRedirectUri: process.env.NEXT_PUBLIC_POST_LOGOUT_URI || "http://localhost:3000",
},
```

- 影響: CIAM/B2C（`*.ciamlogin.com` / `*.b2clogin.com`）の場合にトークン取得・検証で不一致が発生。
- 修正方針: 実運用の認証方式に合わせ、`authority` と `knownAuthorities` を適切に設定。`redirectUri` も Azure ポータル設定と一致させる。

---

## 【Step 1】5. 401時の再取得/再試行フロー未実装

- 根拠: 共通HTTPクライアント（`azureApi.ts`）で401時の `acquireTokenSilent` 再取得→再送の処理が無い。
- 影響: 有効期限切れや初回権限付与時にユーザー体験が破綻。
- 修正方針: 401/403 を捕捉→Access Token 再取得→一度だけ再送→失敗時はログアウト/エラー表示。

---

## 【Step 4】6. ログ/PII 露出リスク

認証関連で詳細ログ出力が多く、PII/機密露出の恐れがあります。

```ts
// src/lib/msal.ts（抜粋）
msalInstance.initialize().then(() => {
  console.log('MSAL initialized');
  return msalInstance.handleRedirectPromise();
}).then((response) => {
  if (response) {
    console.log('Redirect response received:', response);
    msalInstance.setActiveAccount(response.account);
  } else {
    const accounts = msalInstance.getAllAccounts();
    console.log('Found accounts on load:', accounts);
  }
});
```

- 影響: ブラウザログから認証応答やアカウント情報が参照可能に。
- 修正方針: 本番ビルドでは詳細ログを抑制（レベル制御・PII禁止）。開発時のみ最小限に。

---

## 【Step 2】7. 参考: SAS発行関数の認可（匿名）

SAS発行関数が匿名呼び出しのままです。MSALの範囲外ですが、セキュリティ上重要です。

```ts
// api/GetUploadSasUrl/index.ts（抜粋）
app.http("GetUploadSasUrl", {
  methods: ["GET"],
  authLevel: "anonymous", // TODO: Change to "function" in production
  handler: GetUploadSasUrl,
});
```

- 影響: 未認証でもアップロード用SASが取得可能。
- 修正方針: `authLevel: 'function'` 以上＋Access Token 検証（EasyAuth/JWT）を導入。SAS権限は最小・期限短。

---

## まとめ（修正優先度）
1) Authorization ヘッダに Access Token を必須化（全HTTP）
2) MSAL スコープ・authority/knownAuthorities を実環境に統一
3) 権限判定を roles へ統一（または groups へ統一）
4) 401再取得→再試行フローを実装
5) 認証ログの抑制
6) SAS発行関数の匿名禁止＋認可追加

---

## 【Step 1】8. 認可: 役割・グループ・クレーム設計（Admin/User 等）

### 8.1 判定元の不一致（roles と groups の混在）

```ts
// src/hooks/useMsalAuth.ts（抜粋）
const convertMsalAccountToUser = (msalAccount: any) => ({
  userId: msalAccount.localAccountId || msalAccount.homeAccountId,
  username: msalAccount.username || msalAccount.name || "Unknown User",
  email: msalAccount.username,
  groups: msalAccount.idTokenClaims?.groups || [],
});
```

```ts
// src/hooks/useAuthInit-azure.ts（抜粋）
const idTokenClaims = account.idTokenClaims as any;
const roles = idTokenClaims?.roles || [];
const isAdmin = roles.includes('Admin') || roles.includes('admin');
```

- 影響: 画面ガードやストアの`isAdmin`が環境により揺れる（rolesとgroupsで挙動差）。
- 修正方針: テナント方針に合わせ`roles`（appRoles）または`groups`に統一。共通ヘルパーで判定を一元化。

### 8.2 バックエンド認可未実装（トークン検証/ロール検査なし）

```ts
// api/create-session/index.ts（抜粋）
app.http('create-session', {
  methods: ['POST'],
  authLevel: 'function',
  handler: createSession
});
```

- 影響: 関数キー/匿名で呼べてしまう設計のままでは、ロール/グループに基づく認可が機能しない。
- 修正方針: Access Token 検証（EasyAuthまたはミドルウェア）を導入し、ロール/グループに基づく認可を実施。

### 8.3 APIクライアントがBearer未送信

```ts
// src/lib/azureApi.ts（抜粋）
async function request<T = any>(path: string, init?: RequestInit): Promise<T> {
  // NO token logic here for Milestone 1
  const headers: Record<string, string> = {
    'Content-Type': 'application/json',
  };
  const res = await fetch(buildUrl(path), { method: 'POST', headers, ...init });
  // ...
}
```

- 影響: サーバ側が認可を実装しても、クライアントがトークンを送らず401/403を招く。
- 修正方針: `acquireTokenSilent(tokenRequest)`でAccess Token取得→`Authorization: Bearer`付与。

### 8.4 名称の統一（“Admin”）

- 影響: 大文字小文字差異（Admin/admin）や名称の揺れで判定がずれる。
- 修正方針: テナントのapp role/グループ名を“Admin”に固定し、コード側も定数化。

### 8.5 画面ガードとAPI権限の整合

- 影響: UIで不可なのにAPIが通る、またはその逆など、セキュリティ/UXの齟齬。
- 修正方針: 画面ガード（isAdmin）とAPI認可（ロール検査）を同一クレーム・同一名称で実装。E2Eで3パターン（Admin/一般/未割当）を検証。

---

## 【Step 1】9. バックエンド: Access Token 検証（issuer/aud/scp/exp）

本節では HTTP トリガー関数側の JWT 検証・認可に関する不足点を整理します（既に記載済みのフロント側Bearer未送信・SAS匿名は重複回避）。

### 9.1 関数キー依存（function key）での保護に留まる

```ts
// api/create-session/index.ts（抜粋）
app.http('create-session', {
  methods: ['POST'],
  authLevel: 'function', // 関数キー前提の保護
  handler: createSession
});
```

- 問題: 関数キーは秘密共有に依存し、ユーザー単位の認可（ロール/所有者）を実施できません。JWT（Access Token）前提に切り替えるべきです。
- 追記: クライアント側にも function key を送る実装が残存しています。

```ts
// src/lib/azureApi.ts（抜粋）
const fnKey = azureConfig.functions.functionKey || "";
const urlObj = new URL(`${base.replace(/\/$/, '')}/GetUploadSasUrl`);
if (fnKey) urlObj.searchParams.set('code', fnKey);
```

> 備考: `azure-config.ts` に `functions.functionKey` は未定義のため、挙動不整合の恐れがあります（function auth だが code 未付与）。

### 9.2 JWT 検証（issuer/audience/scope/exp）未導入

- 問題: いずれの HTTP 関数でも Authorization ヘッダの JWT（Access Token）検証コードが存在しません。
- 期待: 以下の最低限検証を実施。
  - issuer/tenant: 許可発行者（Entra External ID/B2C のテナント）に限定（`iss`/`tid`）。
  - audience: `aud == api://{APIアプリID}` に一致。
  - scope: `scp` に `access_as_user` を含む（app roles を採用する場合は `roles` で代替）。
  - exp/nbf: 有効期限内であること。
  - 署名: JWKS で署名検証。

### 9.3 認可（ロール/所有者・組織チェック）未実装

- 問題: JWT 検証後のロール（`roles` or `groups`）/所有者・組織の整合確認がありません。
- 期待: エンドポイントごとに Admin 専用/一般ユーザー可、所有者/組織一致の検査を実施。

### 9.4 エラーハンドリング / CORS

- 問題: 401/403 の標準的応答（`WWW-Authenticate`）や CORS 設定（Authorization ヘッダ許可）が未定義。
- 期待: 401（未認証）/403（権限不足）を明確に返し、プリフライトで `Authorization` を許可。

### 9.5 推奨実装（いずれか）

- Option A: EasyAuth（App Service Authentication）
  - Function App で「App Service Authentication」を有効化
  - 許可対象の `issuer`/`allowed token audiences` を明示
  - 関数コード側では `X-MS-CLIENT-PRINCIPAL` を解釈して `oid/roles/groups` を参照
- Option B: 関数内での JWT 検証
  - `Authorization: Bearer <token>` を取得
  - OIDC メタデータから JWKS を取得し署名/iss/aud/scp/exp を検証
  - 併せてロール/所有者・組織の認可を行う
- Option C: API Management (APIM)
  - APIM の `validate-jwt` ポリシーで `issuer`/`audiences` を固定
  - バックエンドへは検証済みのコンテキストヘッダで受け渡し

### 9.6 テスト観点（最小）

- 正常系: 正しい `iss/aud/scp` を持つ Access Token → 200
- 異常系: IDトークン/`aud` 不一致/`scp` 欠落/期限切れ → 401
- 認可: Admin/一般/未割当でエンドポイントごとの 200/403 が期待通り
- CORS: Authorization ヘッダ付きのプリフライトが成功

### 9.7 要修正タスクリスト（要点）

1) クライアント: すべての API 呼出で `Authorization: Bearer <access_token>` を送信（重複記載につき詳細は前節参照）
2) Functions: `authLevel` を JWT 前提に変更（EasyAuth または APIM で検証／もしくは関数内で直接検証）
3) issuer/audience/scope/exp の厳密検証を導入
4) ロール/所有者・組織の認可を各エンドポイントで実装
5) 401/403 と CORS の整備（`WWW-Authenticate`/`Authorization` 許可）

---

## 【Step 1】10. リダイレクトURI/既知オーソリティ設定の整合

### 10.1 authority ドメインの不一致（CIAM/B2C想定時）

```ts
// src/azure-config.ts（抜粋）
export const azureConfig = {
  auth: {
    clientId: process.env.NEXT_PUBLIC_FRONTEND_CLIENT_ID || "",
    authority: `https://login.microsoftonline.com/${process.env.NEXT_PUBLIC_TENANT}`,
    redirectUri: process.env.NEXT_PUBLIC_REDIRECT_URI || "http://localhost:3000",
    postLogoutRedirectUri: process.env.NEXT_PUBLIC_POST_LOGOUT_URI || "http://localhost:3000",
  },
  // ...
}
```

- 問題: External ID/B2C/CIAM を利用する場合は `login.microsoftonline.com` ではなく、`{tenant}.ciamlogin.com`（または `{tenant}.b2clogin.com`＋ポリシー）を authority に設定すべき。
- 修正方針: 実運用のIdP種類に合わせて authority を切替（CIAM: `https://{tenant}.ciamlogin.com`）。

### 10.2 knownAuthorities 未設定（B2C/CIAM で必須）

```ts
// src/azure-config.ts → msalConfig.auth に knownAuthorities が存在しない
export const msalConfig = {
  auth: {
    ...azureConfig.auth,
  },
  // ...
}
```

- 問題: B2C/CIAM では `knownAuthorities: ['{tenant}.ciamlogin.com']` 等の設定が推奨/必須。
- 修正方針: `msalConfig.auth.knownAuthorities` を追加し、ドメイン偽装を防止。

### 10.3 リダイレクトURIの整合（env とポータル登録）

- 問題: `.env` の `NEXT_PUBLIC_REDIRECT_URI`/`NEXT_PUBLIC_POST_LOGOUT_URI` と Azure ポータルのアプリ登録（SPAプラットフォーム）側の登録URIが一致している保証がない（fallback に `http://localhost:3000` を使用）。
- 修正方針: localhost/dev/prod の各URIをポータル側に登録し、フロント設定と完全一致させる。Next.js でルートを分ける場合はパス（例 `/azure`）ごとに登録。

### 10.4 認可フロー/ブラウザ制約

- 問題: SPAはPKCE必須。Safari/ITPで `storeAuthStateInCookie: false` のまま silent 対応が不安定になる可能性。
- 修正方針: 事象がある場合は `storeAuthStateInCookie: true` を検討しつつ、最小限ログのみ許可。

### 10.5 テスト観点

- 正常: localhost/dev/prod でサインイン/サインアウトが期待どおりのURIに遷移し、MSALエラーなく完了。
- 異常: authority/knownAuthorities の不整合や未登録URIで AADSTS/AADB2C エラーが発生することを確認（再発防止）。
- ルート: `/azure` 等のパスを含む遷移でも成功。

### 10.6 要修正タスクリスト（要点）

1) CIAM/B2C の場合、`authority` を正しいドメインへ変更
2) `msalConfig.auth.knownAuthorities` を追加（B2C/CIAM）
3) すべての `redirectUri`/`postLogoutRedirectUri` をポータルに登録し、フロント設定と一致
4) 必要に応じて `storeAuthStateInCookie:true` を検討

---

## 【Step 2】11. ストレージ: 入力/出力コンテナの分離（命名・CORS）

### 11.1 コンテナ命名の不整合

```ts
// src/azure-config.ts（抜粋）
export const azureConfig = {
  storage: {
    accountName: process.env.NEXT_PUBLIC_AZURE_STORAGE_ACCOUNT || "",
    accountKey: process.env.NEXT_PUBLIC_AZURE_STORAGE_KEY || "",
    containerName: 'transcripts',
    outputContainerName: 'outputs',
  },
}
```

```ts
// api/GetUploadSasUrl/index.ts（抜粋）
const containerName = process.env.AZURE_STORAGE_CONTAINER_NAME || "uploads";
```

- 問題: フロントは `transcripts`/`outputs` 前提だが、SAS関数は `uploads` を使用。動線が一致せず、権限分離や運用が不整合。
- 修正方針: SAS発行関数を `transcripts`（入力）に揃え、生成物は別経路で `outputs` を利用。

### 11.2 キー（パス）構造の不一致

```ts
// src/hooks/useMediaUpload-azure.ts（抜粋）
const blobName = `${sessionId}/${file.name}`; // セッション直下
```

```ts
// api/GetUploadSasUrl/index.ts（抜粋）
const blobName = `${uuidv4()}-${fileName}`; // ルート直下にUUID-ファイル名
```

- 問題: 想定の `private/{identityId}/{sessionId}/…` と乖離。後続の所有者/組織照合、クリーンアップ、権限制御設計が難しくなる。
- 修正方針: アップロードSAS生成時に、`identityId`/`sessionId` をキーへ反映させる方針に統一（例: `private/{oid}/{sessionId}/original.ext`）。

### 11.3 CORS 設定の確認不足

- 問題: Blob Service の CORS が最小化されている保証がない（AllowedOrigins/Methods/Headers/ExposeHeaders/MaxAge）。
- 修正方針: 
  - AllowedOrigins: localhost/dev/prod のドメインに限定（ワイルドカード禁止）
  - AllowedMethods: GET/PUT/HEAD（必要に応じて DELETE/OPTIONS）
  - AllowedHeaders: `content-type`, `x-ms-blob-type`, `x-ms-version`, `x-ms-meta-*` など最小限
  - ExposedHeaders: 必要最小限（ETag 等）
  - MaxAge: 300〜600程度
  - 環境ごとに分離運用（本番へ過剰なCORSを適用しない）

### 11.4 Public access（匿名アクセス）

- 問題: コンテナ/Blob 公開設定が「無効」である明示確認がない。
- 修正方針: 両コンテナ（transcripts/outputs）とも Public access を「なし」に設定。アクセスはSASのみ。

### 11.5 テスト観点

- `PUT`（入力）: 許可オリジンから transcripts へSAS経由でアップロード成功、未許可オリジンはCORSエラー
- `GET`（出力）: 許可オリジンから outputs へSAS経由でダウンロード成功
- プリフライト（OPTIONS）成功（必要ヘッダ・メソッドがCORSに反映）
- キー構造が `private/{oid}/{sessionId}/…` で作成されること

---

## 【Step 2】12. アップロード: 短期SAS（サーバー発行）→ クライアントはSASでPUT/ブロックアップロード

### 12.1 サーバー側: SAS発行の問題点

```ts
// api/GetUploadSasUrl/index.ts（抜粋）
const containerName = process.env.AZURE_STORAGE_CONTAINER_NAME || "uploads";
// ...
const permissions = new BlobSASPermissions();
permissions.read = true;      // ← 読み取り不要（アップロード専用なら外す）
permissions.add = true;
permissions.create = true;
permissions.write = true;

const sasUrl = await blockBlobClient.generateSasUrl({
  permissions: permissions,
  expiresOn: new Date(new Date().valueOf() + 60 * 60 * 1000), // ← 1時間は長い
});

app.http("GetUploadSasUrl", {
  methods: ["GET"],
  authLevel: "anonymous", // ← JWT保護が必要
  handler: GetUploadSasUrl,
});
```

- 問題:
  - `authLevel: "anonymous"` のため未認証でSASが取得可能（JWT必須）
  - 権限に `read` を含む（アップロード用途では不要）
  - 期限が1時間と長め（短期≦10分推奨、時計ずれ吸収の `startsOn` 付与）
  - `uploads` コンテナ使用で、設計上の `transcripts` と不一致
  - `uuid-原稿名` 命名で `private/{oid}/{sessionId}/…` と不整合（所有者/クリーンアップ/追跡の観点）

- 修正案（例）:
  - 認証: EasyAuth または関数内JWT検証を導入（Access Token必須）
  - 権限: `BlobSASPermissions.parse('acw')`（add/create/write のみ）
  - 期限: `startsOn: new Date(Date.now()-60_000)`, `expiresOn: new Date(Date.now()+10*60_000)`
  - コンテナ: `transcripts` 固定、`blobName` は `private/{oid}/{sessionId}/original.ext`
  - 返却: `{ sasUrl, blobName }` を返し、フロントはそのままPUT

### 12.2 クライアント側: PUT/ブロックアップロードの確認

```ts
// src/hooks/useMediaUpload.ts（抜粋）
const sasInfo = await getUploadSasUrl(file.name);
const blobClient = new BlockBlobClient(sasInfo.sasUrl);
const result = await blobClient.uploadData(file, {
  blockSize: 4 * 1024 * 1024,
  concurrency: 2,
  onProgress: (progress) => { /* 進捗反映 */ },
});
```

- 評価:
  - `BlockBlobClient` + `uploadData` + `onProgress` は要件に合致（OK）
  - ヘッダ（`x-ms-blob-type: BlockBlob`）はSDKが自動付与、`Content-Type` もブラウザから設定される

- 改善提案:
  - SAS期限切れ/403 時の再発行リトライ導線（UX）
  - `blobName` をサーバー返却値に統一（クライアント側で別命名しない）
  - 大容量時の blockSize/concurrency 調整（回線/端末依存）

### 12.3 クォータ/整合チェック（任意）

- SAS発行前に、組織の残時間/回数チェック（不足時は発行拒否）
- `sessionId` と `blobName` の相関をサーバー側に記録（追跡・クリーンアップ・監査）

### 12.4 テスト観点

- 正常: 許可オリジンから transcripts へ PUT 成功、進捗表示OK
- 異常: 期限切れ/不正SAS/未認証で 401/403、CORS 不許可でプリフライト失敗
- 耐性: 大容量（>1GB）や回線不良時の再試行/キャンセル（AbortSignal）

---

## 【Step 2】13. ダウンロード/削除: SAS/Functions 経由での安全な取得・削除

### 13.1 ダウンロードSAS発行APIの未実装

```ts
// src/lib/azureApi.ts（抜粋）
export async function getAudioPresignedUrl(sessionId: string): Promise<string> {
  return request<string>(azureConfig.functions.endpoints.getAudioUrl, {
    body: JSON.stringify({ sessionId }),
  });
}
```

- 問題: `/api/get-audio-url` に相当する関数実装が `api/` 配下に存在しないため、ダウンロードSASを取得できない。
- 修正方針: outputs コンテナ向け read のみ/短期SAS を発行する HTTP 関数を実装（JWT必須、`oid`/組織/所有者検証）。

### 13.2 削除APIの未実装

```ts
// src/lib/azureApi.ts（抜粋）
export async function deleteGeneratedFiles(sessionId: string): Promise<void> {
  await request<void>(azureConfig.functions.endpoints.deleteFiles, {
    body: JSON.stringify({ sessionId }),
  });
}
```

- 問題: `/api/delete-files` に相当する関数実装が見当たらない。冪等削除/監査/所有者検証が未実装。
- 修正方針: Functions 側で `private/{oid}/{sessionId}/…` の生成物を列挙→削除し、セッション/DBにも削除済み状態を反映。必ずJWT検証のうえで実行。

### 13.3 認可・権限の最小化

- 問題: ダウンロードSASの権限/期限、削除権限のクライアント委譲の設計が未確立。
- 修正方針:
  - ダウンロードSAS: `read` のみ、期限≦10分、`startsOn` で時計ずれ吸収。outputs のみに限定。
  - 削除: クライアントに delete 用SAS を渡さず、必ず Functions 経由で実行（JWT検証＋所有者/組織検証）。

### 13.4 監査・相関/エラー設計

- 監査: 誰が何をDL/削除したか（userId/orgId/sessionId/blobName/時刻）を記録、相関IDを付与。
- エラー: 401/403/404/410（期限切れ/権限不足/不存在/既削除）を明確化、`WWW-Authenticate`（401）付与。

### 13.5 テスト観点

- 正常: outputs の対象ファイルに対して SAS 取得→GET でダウンロード成功。削除APIで冪等に削除→再取得で 404/410。
- 異常: 別ユーザー/組織のセッションは 403。期限切れSAS は 403（再発行で回復）。
- CORS: 許可外オリジンはプリフライト/本リクエストとも拒否。

---

## 【Step 2】14. 階層構造の準拠（private/{identityId(oid)}/{sessionId}/...）

### 14.1 現状の不一致点

```ts
// src/hooks/useMediaUpload-azure.ts（抜粋）
const blobName = `${sessionId}/${file.name}`; // ← identityId(oid) 不在
```

```ts
// api/GetUploadSasUrl/index.ts（抜粋）
const blobName = `${uuidv4()}-${fileName}`; // ← 規約外の平置き命名（階層未使用）
```

- 問題:
  - 入力アップロードが `sessionId/filename` で `oid` を含まず、規約の `private/{oid}/{sessionId}/…` から逸脱
  - SAS関数は `uuid-filename` 命名で同様に規約外。所有者/組織照合、クリーンアップ、一覧性が損なわれる
  - クライアント側が命名を決める余地があり、サーバ設計と乖離する恐れ

### 14.2 推奨方針（統一ルール）

- 入力（transcripts）: `private/{oid}/{sessionId}/original.{ext}`
- 出力（outputs）: `private/{oid}/{sessionId}/{type}.{ext}` 例: `transcript.json`, `bullets.md`, `minutes.md`, `tasks.xlsx`
- blobName の決定権はサーバ（Functions）に集約し、クライアントは返却された `blobName` のみ使用

### 14.3 実装案

- SAS発行関数で `oid` と `sessionId` を受領し、サーバ側で規約に沿った `blobName` を構築
- ダウンロード/削除APIも上記規約に従う（prefix指定の範囲操作で所有者/セッションを限定）
- `listBlobsFlat({ prefix: \`private/${oid}/${sessionId}/\` })` を用いた範囲取得で誤操作を防止
- セッションレコードに `blobName` 一覧（もしくはベースプレフィックス）を保持して相関追跡

### 14.4 バリデーション/安全性

- `oid`/`sessionId` の入力検証（英数・ハイフンのみ等、最大長）
- パストラバーサルを防止（`..` やスラッシュ注入の拒否）
- 入力ファイル拡張子/MIMEの許容範囲チェック

### 14.5 テスト観点

- アップロード→処理→出力生成で、全ファイルが `private/{oid}/{sessionId}/…` に揃う
- 別ユーザー/組織のパス要求に 403 を返す（JWT+パス整合）
- 一括削除で当該プレフィックス配下が冪等に削除される
